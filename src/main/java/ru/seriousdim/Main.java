package ru.seriousdim;

import ru.seriousdim.parser.exceptions.ParsingException;
import ru.seriousdim.service.cache.basic.SetCacheService;
import ru.seriousdim.service.cache.TreeSetCacheService;
import ru.seriousdim.service.worker.CacheWorker;


import java.io.IOException;
import java.util.List;

/**
 * <p>
 *      Алгоритм реализован в методе {@link SetCacheService#analyseAll(List)}
 * </p>
 *
 * <p>
 *      Класс {@link SetCacheService} реализует алгоритм кэша на основе любой коллекции, которая
 *      имплементирует {@link java.util.Set}
 *      Данный класс наследуется классом {@link TreeSetCacheService}, который использует {@link java.util.TreeSet}
 *      в качестве коллекции для кэша.
 * </p>
 *
 * <p>
 *      <h2>Описание алгоритма кэширования:</h2>
 *      <h3>Этап 1: препроцессинг </h3>
 *
 *      <p>
 *          На этом этапе надо узнать для каждого идентификатора (id) его самую последнюю
 *          позицию (индекс) в списке запросов. Эта информация нужна, чтобы реализовать кэш
 *          согласно алгоритму Белади: если места в кэше не хватает, то
 *          отбрасываем из кэша ту информацию, которая не понадобится в будущем дольше всего
 *      </p>
 *
 *      <ol>
 *          <li>Создадим {@link java.util.HashMap} с именем lastPositions. Ключ - id, значение - индекс позиции</li>
 *          <li>
 *              Пройдемся по индексам всех id
 *              <ol>
 *                  <li>
 *                      Вставим в lastPositions текущий индекс:
 *                      ключ - id по данному индексу, значение - текущий индекс
 *                  </li>
 *                  <li>
 *                      Если ключ уже есть в lastPositions, то просто перезапишем его значение
 *                      текущим индексом, так как он точно будет больше
 *                  </li>
 *              </ol>
 *          </li>
 *          <li>
 *              В итоге в lastPositions будет информация о последних позициях для
 *              каждого id
 *          </li>
 *      </ol>
 *
 *      <p>
 *          Сложность: O(m), где m - кол-во запросов
 *      </p>
 *
 *      <h3>Этап 2: поиск ответа</h3>
 *
 *      <p>
 *          Пусть e будет каким-то id из списка запросов, ind - его индекс
 *      </p>
 *
 *      <ol>
 *          <li>
 *              Для каждого e, ind в списке запросов возможны следующие сценарии:
 *
 *              <ol>
 *                  <li>
 *                      e есть в кэше и ind == lastPositions[e]
 *                      <ol>
 *                          <li>
 *                              Удалим e из кэша, так как он больше не понадобится
 *                          </li>
 *                      </ol>
 *                  </li>
 *                  <li>
 *                      e есть в кэше и ind != lastPositions[e]
 *                      <ol>
 *                          <li>
 *                              Ничего не делаем, так как e еще понадобится
 *                          </li>
 *                      </ol>
 *                  </li>
 *                  <li>
 *                      e нет в кэше
 *                      <ol>
 *                          <li>
 *                              Это означает, что мы сделаем запрос к серверу - можно прибавить 1 к ответу
 *                          </li>
 *                          <li>
 *                              Если ind != lastPositions[e], то мы добавим e в кэш, так как он еще может встретиться.
 *                              Инчае добавлять e не имеет смысла
 *                          </li>
 *                          <li>
 *                              Если нужно добавить e в кэш и место в кэше кончилось, нужно удалить из него 1 элемент -
 *                              такой, который понадобится нам позже всех. Алгоритм выбора такого элемента реализован в
 *                              {@link TreeSetCacheService#removeMostUselessElement()}
 *                          </li>
 *                      </ol>
 *                  </li>
 *              </ol>
 *          </li>
 *      </ol>
 *
 *      <p>
 *          Сложность: каждый из описанных сценариев при использовании {@link java.util.TreeSet} работает с асимптотикой
 *          O ( log c ), где c - текущее количество элементов в кэше.
 *          Поэтому сложность данного этапа будет O ( m log c ), где m - кол-во запросов
 *      </p>
 *
 * </p>
 *
 * <p>
 *      <h2>Итоговая сложность (используя {@link java.util.TreeSet}):</h2>
 *      O(m log c), где:
 *
 *      m - кол-во запросов, которые надо обработать,
 *      c - текущее кол-во элементов в кэше (кол-во элементов в {@link java.util.TreeSet})
 * </p>
 *
 * <p>
 *      <h2>Сравнение с {@link java.util.HashSet}</h2>
 *
 *      <p>
 *          Добавление, удаление и поиск в:
 *          <ol>
 *              <li>
 *                  {@link java.util.HashSet} - O (1)
 *              </li>
 *              <li>
 *                  {@link java.util.TreeSet} - O ( log n ), n - кол-во элементов в TreeSet
 *              </li>
 *          </ol>
 *      </p>
 *
 *      <p>
 *          Несмотря на то, что все операции в HashSet быстрее, чем в TreeSet,
 *          в HashSet мы вынуждены перебрать все элементы в нем и сравнивать их индексы в lastPositions,
 *          чтобы найти максимальный по индексу id - сложность этого будет O(c), с - кол-во элементов в кэше.
 *          В TreeSet мы можем сразу найти максимальный по индексу id за O(1), но при
 *          этом жертвуя остальными операциями.
 *      </p>
 *
 *      <p>
 *          По тестам можно сделать вывод, что прирост по быстродействию в обычных ситуациях незначительный,
 *          однако есть очень большой прирост в случаях, когда требуется часто удалять элементы из кэша
 *          (то есть искать максимальный по индексу элемент в кэше).
 *      </p>
 *
 *      <p>
 *          HashSet не отрабатывает 3 секунды тест SetCacheServiceTests#testUpperBound7, а тест
 *          SetCacheServiceTests#testUpperBound8 отрабатывает больше всех остальных.
 *      </p>
 *
 *      <p>
 *          HashSet отрабатывает все тесты в среднем за 900 мс (без SetCacheServiceTests#testUpperBound7),
 *          TreeSet - за 300 мс в среднем (включая SetCacheServiceTests#testUpperBound7). TreeSet имеет явно лучшую
 *          производительность.
 *      </p>
 *
 * </p>
 *
 * @author Дмитрий Лыков
 */
public class Main {
    public static void main(String[] args) throws IOException, ParsingException {
        var worker = new CacheWorker();

        worker.analyse("input.txt");
    }
}